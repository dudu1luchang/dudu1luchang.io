<h1 id="任务八-综合案例"><a href="#任务八-综合案例" class="headerlink" title="任务八  综合案例"></a>任务八  综合案例</h1><h2 id="1-商城案例表设计"><a href="#1-商城案例表设计" class="headerlink" title="1.商城案例表设计"></a>1.商城案例表设计</h2><p>通过对商城项目的部分表关系进行分析,完成数据库表的设计</p>
<h3 id="1-1-表关系分析"><a href="#1-1-表关系分析" class="headerlink" title="1.1 表关系分析"></a>1.1 表关系分析</h3><p><img src="/02_%E5%9B%BE%E7%89%87%5C01.jpg"> </p>
<h3 id="1-2-建库-建表"><a href="#1-2-建库-建表" class="headerlink" title="1.2 建库,建表"></a>1.2 建库,建表</h3><ol>
<li>创建名为 store的数据库, 对应商城项目</li>
</ol>
<pre><code class="mysql">create database db6 character set utf8;
</code></pre>
<ol start="2">
<li>创建用户表</li>
</ol>
<pre><code class="mysql">CREATE TABLE user (
  uid varchar(32) PRIMARY KEY,	-- 用户ID
  username varchar(20) , -- 用户名
  password varchar(20) , -- 密码
  telephone varchar(20) , -- 电话
  birthday date , -- 生日
  sex varchar(10) -- 性别
);
</code></pre>
<pre><code class="mysql">INSERT INTO USER VALUES 
(&#39;001&#39;,&#39;渣渣辉&#39;,&#39;123456&#39;,&#39;13511112222&#39;,&#39;2015-11-04&#39;,&#39;男&#39;),
(&#39;002&#39;,&#39;药水哥&#39;,&#39;123456&#39;,&#39;13533334444&#39;,&#39;1990-02-01&#39;,&#39;男&#39;),
(&#39;003&#39;,&#39;大明白&#39;,&#39;123456&#39;,&#39;13544445555&#39;,&#39;2015-11-03&#39;,&#39;男&#39;),
(&#39;004&#39;,&#39;长海&#39;,&#39;123456&#39;,&#39;13566667777&#39;,&#39;2000-02-01&#39;,&#39;男&#39;),
(&#39;005&#39;,&#39;乔杉&#39;,&#39;123456&#39;,&#39;13588889999&#39;,&#39;2000-02-01&#39;,&#39;男&#39;);
</code></pre>
<ol start="3">
<li>创建订单表</li>
</ol>
<pre><code class="mysql">CREATE TABLE orders (
  oid varchar(32)   PRIMARY KEY, -- 订单id
  ordertime datetime ,	-- 下单时间 
  total double , -- 总金额
  name varchar(20), -- 收货人姓名
  telephone varchar(20) , -- 电话
  address varchar(30) , -- 地址
  state int(11) ,  -- 订单状态
  uid varchar(32), -- 外键字段 对应用户表id
  CONSTRAINT ofk_0001 FOREIGN KEY (uid) REFERENCES user (uid)
);
</code></pre>
<pre><code class="mysql">-- 插入一条订单数据
INSERT INTO orders 
VALUES(&#39;order001&#39;,&#39;2019-10-11&#39;,5500,&#39;乔杉&#39;,&#39;15512342345&#39;,&#39;皇家洗浴&#39;,0,&#39;001&#39;);
</code></pre>
<ol start="4">
<li>创建商品分类表</li>
</ol>
<pre><code class="mysql">CREATE TABLE category (
  cid varchar(32) PRIMARY KEY,
  cname varchar(20)
); 
</code></pre>
<pre><code class="mysql">INSERT INTO `category` VALUES (&#39;1&#39;,&#39;手机数码&#39;),(&#39;2&#39;,&#39;电脑办公&#39;),(&#39;3&#39;,&#39;运动鞋服&#39;),(&#39;4&#39;,&#39;图书音像&#39;);
</code></pre>
<ol start="5">
<li>创建商品表</li>
</ol>
<pre><code class="mysql">CREATE TABLE product (
  pid varchar(32)  PRIMARY KEY,	-- 商品id
  pname varchar(50) , -- 商品名称 
  price double, -- 商品价格
  pdesc varchar(255), -- 商品描述
  pflag int(11) , -- 商品状态 1 上架 ,0 下架
  cid varchar(32) , -- 外键对应 分类表id
  KEY sfk_0001 (cid), 
  CONSTRAINT sfk_0001 FOREIGN KEY (cid) REFERENCES category (cid)
);
</code></pre>
<pre><code class="mysql">INSERT INTO `product` VALUES 
(&#39;1&#39;,&#39;小米6&#39;,2200,&#39;小米 移动联通电信4G手机 双卡双待&#39;,0,&#39;1&#39;),
(&#39;2&#39;,&#39;华为Mate9&#39;,2599,&#39;华为 双卡双待 高清大屏&#39;,0,&#39;1&#39;),
(&#39;3&#39;,&#39;OPPO11&#39;,3000,&#39;移动联通 双4G手机&#39;,0,&#39;1&#39;),
(&#39;4&#39;,&#39;华为荣耀&#39;,1499,&#39;3GB内存标准版 黑色 移动4G手机&#39;,0,&#39;1&#39;),
(&#39;5&#39;,&#39;华硕台式电脑&#39;,5000,&#39;爆款直降，满千减百&#39;,0,&#39;2&#39;),
(&#39;6&#39;,&#39;MacBook&#39;,6688,&#39;128GB 闪存&#39;,0,&#39;2&#39;),
(&#39;7&#39;,&#39;ThinkPad&#39;,4199,&#39;轻薄系列1)&#39;,0,&#39;2&#39;),
(&#39;8&#39;,&#39;联想小新&#39;,4499,&#39;14英寸超薄笔记本电脑&#39;,0,&#39;2&#39;),
(&#39;9&#39;,&#39;李宁音速6&#39;,500,&#39;实战篮球鞋&#39;,0,&#39;3&#39;),
(&#39;10&#39;,&#39;AJ11&#39;,3300,&#39;乔丹实战系列&#39;,0,&#39;3&#39;),
(&#39;11&#39;,&#39;AJ1&#39;,5800,&#39;精神小伙系列&#39;,0,&#39;3&#39;);
</code></pre>
<ol start="5">
<li>订单项表 (中间表)</li>
</ol>
<pre><code class="mysql">-- 订单项表
CREATE TABLE orderitem (
  itemid VARCHAR(32) PRIMARY KEY, -- 订单项ID
  pid VARCHAR(32),  -- 外键 对应商品表 id
  oid VARCHAR(32), -- 外键 对应订单表 id
  KEY fk_0001 (pid),
  KEY fk_0002 (oid),
  CONSTRAINT fk_0001 FOREIGN KEY (pid) REFERENCES product (pid),
  CONSTRAINT fk_0002 FOREIGN KEY (oid) REFERENCES orders (oid)
);
</code></pre>
<pre><code class="mysql">-- 向中间表中插入两条数据
INSERT INTO orderitem VALUES(&#39;item001&#39;,&#39;1&#39;,&#39;order001&#39;);
INSERT INTO orderitem VALUES(&#39;item002&#39;,&#39;11&#39;,&#39;order001&#39;);
</code></pre>
<h2 id="2-环境搭建"><a href="#2-环境搭建" class="headerlink" title="2.环境搭建"></a>2.环境搭建</h2><h3 id="2-1-项目结构"><a href="#2-1-项目结构" class="headerlink" title="2.1 项目结构"></a>2.1 项目结构</h3><pre><code>com.lagou.app 测试包 用于对DAO代码进行测试
com.lagou.dao dao包  数据访问层,包含所有对数据库的相关操作的类
com.lagou.entity 实体包 保存根据数据库表 对应创建的JavaBean类
com.lagou.utils 工具包
</code></pre>
<p><img src="/02_%E5%9B%BE%E7%89%87%5C03.jpg"> </p>
<h3 id="2-2-导入所需Jar包"><a href="#2-2-导入所需Jar包" class="headerlink" title="2.2 导入所需Jar包"></a>2.2 导入所需Jar包</h3><pre><code>我们只需要导入myjar仓库到项目中就可以了
</code></pre>
<p><img src="/02_%E5%9B%BE%E7%89%87%5C04.jpg"> </p>
<h3 id="2-3-导入配置文件及工具类"><a href="#2-3-导入配置文件及工具类" class="headerlink" title="2.3 导入配置文件及工具类"></a>2.3 导入配置文件及工具类</h3><p><img src="/02_%E5%9B%BE%E7%89%87%5C05.jpg"> </p>
<h2 id="3-JavaBean类创建"><a href="#3-JavaBean类创建" class="headerlink" title="3.JavaBean类创建"></a>3.JavaBean类创建</h2><h3 id="3-1-设计用户与订单"><a href="#3-1-设计用户与订单" class="headerlink" title="3.1 设计用户与订单"></a>3.1 设计用户与订单</h3><h4 id="3-1-1-一对多关系分析"><a href="#3-1-1-一对多关系分析" class="headerlink" title="3.1.1 一对多关系分析"></a>3.1.1 一对多关系分析</h4><ul>
<li><p>在Java一对多的数据关系中，需要遵循以下设计原则：</p>
</li>
<li><ol>
<li>Java类的名称 &#x3D; 实体表的名称</li>
<li>Java类的属性 &#x3D; 实体表的字段</li>
<li>Java类的一个对象 &#x3D; 表的一行记录</li>
<li>外键关系 &#x3D; 引用配置</li>
</ol>
</li>
<li><p>一个用户拥有多个订单,所以 用户是一的一方, 订单是多的一方</p>
<p><img src="/02_%E5%9B%BE%E7%89%87%5C06.jpg"></p>
</li>
</ul>
<h4 id="3-1-2-User类"><a href="#3-1-2-User类" class="headerlink" title="3.1.2 User类"></a>3.1.2 User类</h4><pre><code class="java">/**
 *    用户表 对应 User类
 *   `uid` VARCHAR(32) NOT NULL,
 *   `username` VARCHAR(20) DEFAULT NULL,
 *   `password` VARCHAR(20) DEFAULT NULL,
 *   `telephone` VARCHAR(20) DEFAULT NULL,
 *   `birthday` DATE DEFAULT NULL,
 *   `sex` VARCHAR(10) DEFAULT NULL,
 * */
public class User {

    private String uid;

    private String username;

    private String password;

    private String telephone;

    private String birthday;

    private String sex;

      //提供 get set toString方法
}
</code></pre>
<h4 id="3-1-3-Orders类"><a href="#3-1-3-Orders类" class="headerlink" title="3.1.3 Orders类"></a>3.1.3 Orders类</h4><pre><code class="java">/**
 *   订单表
 *   `oid` VARCHAR(32) NOT NULL,
 *   `ordertime` DATETIME DEFAULT NULL,
 *   `total` DOUBLE DEFAULT NULL,
 *   `name` VARCHAR(20) DEFAULT NULL,
 *   `telephone` VARCHAR(20) DEFAULT NULL,
 *   `address` VARCHAR(30) DEFAULT NULL,
 *   `state` INT(11) DEFAULT NULL,
 *   `uid` VARCHAR(32) DEFAULT NULL,
 *
 * */
public class Orders {

    private String oid; //订单号
    private String ordertime; //下单时间
    private double total; //订单的总金额
    private String name; //收货人姓名
    private String telephone; //收货人电话
    private String address;  //收货人地址
    private int state; //订单状态 1 代表已支付 , 0 代表未支付

    //订单属于哪个用户呢 ?
    
    //提供 get set toString方法
}
</code></pre>
<h4 id="3-1-4-Orders类设计分析"><a href="#3-1-4-Orders类设计分析" class="headerlink" title="3.1.4 Orders类设计分析"></a>3.1.4 Orders类设计分析</h4><ul>
<li><p>第一种方式</p>
<ul>
<li><p>根据两张表关系的描述  我们可以在 订单类中 添加一个uid 成员变量,表示订单属于哪个用户</p>
<pre><code class="java">private String uid;
</code></pre>
</li>
<li><p>但是这样设计会存在一些问题,比如 我要查询的是订单是属于哪个用户的用户名 ? 但是我们只有一个uid</p>
</li>
</ul>
</li>
<li><p>第二种方式</p>
<ul>
<li><p>Java类表示一对多关系,可以在多的一方添加一个成员变量,这个成员变量的类型 就是一的一方的类型.</p>
</li>
<li><p>再在订单表中 添加一个 User对象,User对象中 ,保存该订单关联的用户的所有信息</p>
<pre><code class="java">private String uid;
private User user;
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="3-1-4-修改Orders类"><a href="#3-1-4-修改Orders类" class="headerlink" title="3.1.4 修改Orders类"></a>3.1.4 修改Orders类</h4><pre><code class="java">public class Orders {

    private String oid; //订单号
    private String ordertime; //下单时间
    private double total; //订单的总金额
    private String name; //收货人姓名
    private String telephone; //收货人电话
    private String address;  //收货人地址
    private int state; //订单状态 1 代表已支付 , 0 代表未支付

    //订单属于哪个用户呢 ?
    private String uid; //表示外键
    private User user; //用来保存订单对应的详细的用户信息
    
    //提供 get set toString方法
}
</code></pre>
<h3 id="3-2-设计商品与分类"><a href="#3-2-设计商品与分类" class="headerlink" title="3.2 设计商品与分类"></a>3.2 设计商品与分类</h3><p>分类与商品 同样是一对多关系,  我们可以在多的一方进行操作 添加一个成员变量 类型是一的一方的类型</p>
<p><img src="/02_%E5%9B%BE%E7%89%87%5C07.jpg"> </p>
<h4 id="3-2-1-Category类"><a href="#3-2-1-Category类" class="headerlink" title="3.2.1 Category类"></a>3.2.1 Category类</h4><pre><code class="java">public class Category {

    private String cid;
    private String cname;
    
    //提供 get set toString方法
}
</code></pre>
<h4 id="3-2-2-Product类"><a href="#3-2-2-Product类" class="headerlink" title="3.2.2 Product类"></a>3.2.2 Product类</h4><pre><code class="java">public class Product {

    private String pid;

    private String pname;

    private double price;

    private String pdesc;

    private int pflag; //是否上架 1 上架 ,0 下架

    private String cid; //外键 对应分类表主键

    private Category category; //用于保存Category的详细数据
    
     //提供 get set toString方法
}
</code></pre>
<h3 id="3-3-设计订单项"><a href="#3-3-设计订单项" class="headerlink" title="3.3 设计订单项"></a>3.3 设计订单项</h3><h4 id="3-3-1-多对多关系分析"><a href="#3-3-1-多对多关系分析" class="headerlink" title="3.3.1 多对多关系分析"></a>3.3.1 多对多关系分析</h4><p>商品与订单是多对多关系, 一个订单上可以有多个商品, 一个商品可以出现在多个订单中.</p>
<p>多对多建表原则 需要一张中间表,中间表中至少有两个字段,作为中间表的外键分别指向另外两张表的主键</p>
<p><img src="/02_%E5%9B%BE%E7%89%87%5C11.jpg">  </p>
<h4 id="3-3-2-创建OrderItem"><a href="#3-3-2-创建OrderItem" class="headerlink" title="3.3.2 创建OrderItem"></a>3.3.2 创建OrderItem</h4><pre><code class="java">/**
 *   订单项表(中间表)
 *   `itemid` VARCHAR(32) NOT NULL,
 *   `pid` VARCHAR(32) DEFAULT NULL,
 *   `oid` VARCHAR(32) DEFAULT NULL,
 *
 * */
public class OrderItem {

    //订单项 指的是中间表中的一条数据
    private String itemid; //订单项的id

    private String pid; //外键 指向商品表主键

    private String oid; //外键 指向订单表的主键
    
    private Product product;//订单项内部的商品详细信息

    private Orders orders;//订单项属于哪个订单
    
}
</code></pre>
<h2 id="4-编写DAO类"><a href="#4-编写DAO类" class="headerlink" title="4.编写DAO类"></a>4.编写DAO类</h2><h3 id="4-1-UserDao"><a href="#4-1-UserDao" class="headerlink" title="4.1 UserDao"></a>4.1 UserDao</h3><ul>
<li>需求一: 编写一个注册用户的方法,接收的参数是一个User对象</li>
<li>需求二: 编写一个 用户登录的方法,接收的参数是 用户名 和密码, 返回值是User对象</li>
</ul>
<h4 id="4-1-1-编写UserDao"><a href="#4-1-1-编写UserDao" class="headerlink" title="4.1.1 编写UserDao"></a>4.1.1 编写UserDao</h4><pre><code class="java">public class UserDao {

    /**
     * 注册用户
     * */
    public int register(User user) throws SQLException {

        //1.获取QueryRunner
        QueryRunner qr = new QueryRunner(DruidUtils.getDataSource());

        //2.编写SQL
        String sql = &quot;insert into user values(?,?,?,?,?,?)&quot;;

        Object[] param = {user.getUid(), user.getUsername(), user.getPassword(),
                user.getTelephone(), user.getBirthday(), user.getSex()};

        //3.执行插入操作
        int update = qr.update(sql,param);

        //4.返回受影响的行数
        return update;
    }

    /**
     * 用户注册
     * */
    public User login(String username , String password) throws SQLException {

        QueryRunner qr = new QueryRunner(DruidUtils.getDataSource());

        String sql = &quot;select * from user where username = ? and password = ?&quot;;

        //返回的是一个User对象 使用BeanHandler将结果集的第一条和数据封装到一个Javabean中
        User user = qr.query(sql, new BeanHandler&lt;User&gt;(User.class), username, password);

        return user;
    }

}
</code></pre>
<h4 id="4-1-2-测试注册与登录功能"><a href="#4-1-2-测试注册与登录功能" class="headerlink" title="4.1.2 测试注册与登录功能"></a>4.1.2 测试注册与登录功能</h4><pre><code class="java">public class TestUserDao {

    //创建UserDao
    UserDao userDao = new UserDao();

    //测试注册功能
    @Test
    public void testRegister() throws SQLException {

        //1. 创建User对象
        User user = new User();

        //2. 对User对象进行赋值
        user.setUid(UUIDUtils.getUUID());
        user.setUsername(&quot;大郎&quot;);
        user.setPassword(&quot;654321&quot;);
        user.setTelephone(&quot;15052005200&quot;);
        user.setSex(&quot;男&quot;);
        user.setBirthday(DateUtils.getDateFormart());

        //3.执行注册
        int register = userDao.register(user);

        //4.判断注册是否成功
        if(register &gt; 0){
            System.out.println(&quot;注册成功,欢迎您: &quot; + user.getUsername());
        }else{
            System.out.println(&quot;注册失败! !&quot;);
        }

    }

    //测试登录功能
    @Test
    public void testLogin() throws SQLException {

        //调用UserDao的 login方法,传入用户名密码
        User user = userDao.login(&quot;大郎&quot;, &quot;654321&quot;);

        //判断user不为空 登录成功
        if(user != null){
            System.out.println(user.getUsername() +&quot; 欢迎您!&quot;);
        }else{
            System.out.println(&quot;用户名或者密码错误! !&quot;);
        }

    }
}
</code></pre>
<h3 id="4-2-ProductDao"><a href="#4-2-ProductDao" class="headerlink" title="4.2 ProductDao"></a>4.2 ProductDao</h3><ul>
<li><p>需求1: 根据商品ID 获取商品名称 ,商品价格 以及商品所属分类的名称</p>
<ul>
<li>参数 pid, 返回值 product对象</li>
</ul>
</li>
<li><p>需求2: 根据分类ID 获取商品分类信息</p>
<ul>
<li>参数 cid , 返回值 category对象</li>
</ul>
</li>
<li><p>需求3: 查询指定分类ID 下的商品个数</p>
<ul>
<li>参数 cid , 返回值 int类型 商品个数</li>
</ul>
</li>
<li><p>需求4: 查询指定分类ID 下的所有商品信息</p>
<ul>
<li>参数分类ID ,返回值 List集合 集合中保存商品对象</li>
</ul>
</li>
</ul>
<h4 id="4-2-1-编写-ProductDao"><a href="#4-2-1-编写-ProductDao" class="headerlink" title="4.2.1 编写 ProductDao"></a>4.2.1 编写 ProductDao</h4><pre><code class="java">public class ProductDao {

    //1.根据商品ID 获取商品名称 ,商品价格 以及商品所属分类的名称
    public Product findProductById(String pid) throws SQLException {

        QueryRunner qr = new QueryRunner(DruidUtils.getDataSource());

        String sql = &quot;select * from product where pid = ?&quot;;

        Product product = qr.query(sql, new BeanHandler&lt;Product&gt;(Product.class), pid);

        //调用 findCategoryById()方法, 传递外键cid 获取商品对应 的分类信息
        Category category = findCategoryById(product.getCid());

        //将category保存到商品对象中
        product.setCategory(category);

        return product;
    }

    //2.根据分类ID 获取商品分类信息
    public Category findCategoryById(String cid) throws SQLException {

        QueryRunner qr = new QueryRunner(DruidUtils.getDataSource());

        String sql = &quot;select * from category where cid = ?&quot;;

        Category category = qr.query(sql, new BeanHandler&lt;Category&gt;(Category.class),cid);

        return category;
    }

    //3.查询指定分类ID 下的商品个数
    public int getCount(String cid) throws SQLException {
        QueryRunner qr = new QueryRunner(DruidUtils.getDataSource());

        String sql = &quot;select count(*) from product where cid = ?&quot;;

        //获取的单列数据 ,使用ScalarHandler 封装
        Long count = (Long)qr.query(sql,new ScalarHandler&lt;&gt;(),cid);

        //将Lang类型转换为 int 类型,并返回
        return count.intValue();
    }


    //4.查询指定分类下的所有商品信息
    public List&lt;Product&gt; findProductByCid(String cid) throws SQLException {
        
        QueryRunner qr = new QueryRunner(DruidUtils.getDataSource());
        
        String sql = &quot;select * from product where cid = ?&quot;;

        //查询结果是一个List集合, 使用BeanListHandler 封装结果集
        List&lt;Product&gt; list = qr.query(sql, new BeanListHandler&lt;Product&gt;(Product.class), cid);
        
        return list;
    }
}
</code></pre>
<h4 id="4-2-2-测试-ProductDao"><a href="#4-2-2-测试-ProductDao" class="headerlink" title="4.2.2 测试 ProductDao"></a>4.2.2 测试 ProductDao</h4><pre><code class="java">public class TestProductDao {

    ProductDao productDao = new ProductDao();

    //1.测试 根据商品ID 获取商品名称 ,商品价格 以及商品所属分类的名称
    @Test
    public void testFindProductById() throws SQLException {

        Product product = productDao.findProductById(&quot;1&quot;);

        System.out.println(&quot;商品名称: &quot;+product.getPname()+ &quot;, 商品价格: &quot; + product.getPrice() +
                &quot;, 商品所属分类: &quot;+ product.getCategory().getCname());
    }


    //2.测试 查询指定分类ID下的商品数
    @Test
    public void testGetCount() throws SQLException {
        //查询 cid为3的分类下有多少个商品
        int count = productDao.getCount(&quot;3&quot;);
        System.out.println(&quot;分类ID为3的分类下商品个数: &quot; + count);
    }

    //3.测试 查询指定分类下的所有商品信息
    @Test
    public void testFindProductByCid() throws SQLException {

        //查询cid为 2的分类下 所有的商品信息
        List&lt;Product&gt; list = productDao.findProductByCid(&quot;2&quot;);

        for (Product product : list) {
            System.out.println(product);
        }

    }
}
</code></pre>
<h3 id="4-3-OrdersDao"><a href="#4-3-OrdersDao" class="headerlink" title="4.3 OrdersDao"></a>4.3 OrdersDao</h3><h4 id="4-3-1-多对一分析"><a href="#4-3-1-多对一分析" class="headerlink" title="4.3.1 多对一分析"></a>4.3.1 多对一分析</h4><p>OrderItem表与Orders表的关系是 多对一</p>
<p><img src="/02_%E5%9B%BE%E7%89%87%5C09.jpg"> </p>
<p>之前我们一直是在描述一对多,那么我们再反向描述一下 多对一</p>
<p>方式是在Orders中应该有一个 集合用来保存订单中的订单项信息</p>
<p><img src="/02_%E5%9B%BE%E7%89%87%5C10.jpg"> </p>
<p>在Orders类中添加 订单项的集合</p>
<pre><code class="java">     //该订单中有多少订单项
    List&lt;OrderItem&gt; orderItems = new ArrayList&lt;OrderItem&gt;();

    public List&lt;OrderItem&gt; getOrderItems() {
        return orderItems;
    }

    public void setOrderItems(List&lt;OrderItem&gt; orderItems) {
        this.orderItems = orderItems;
    }
</code></pre>
<h4 id="4-3-2-创建OrdersDao"><a href="#4-3-2-创建OrdersDao" class="headerlink" title="4.3.2 创建OrdersDao"></a>4.3.2 创建OrdersDao</h4><ul>
<li><p>需求1: 获取 uid为 001 的用户的所有订单信息</p>
</li>
<li><p>参数 uid, 返回值 LIst<Orders> 订单集合 </p>
</li>
<li><p>需求2: 获取订单编号为 order001的订单中的所有商品信息</p>
<ul>
<li>参数 oid, 返回值List<Product> 商品集合</li>
</ul>
<pre><code class="sql">-- 获取订单编号为: order001的订单中的所有商品信息

-- 1.查询订单项表中 oid是order001的 所有商品信息
SELECT 
    oi.pid
FROM orderitem oi WHERE oid = &#39;order001&#39;;

-- 2.将上面的查询语句作为in函数的条件, 查询product表
SELECT * FROM product WHERE pid IN
(SELECT 
    oi.pid
FROM orderitem oi WHERE oid = &#39;order001&#39;);
</code></pre>
</li>
</ul>
<pre><code class="java">public class OrdersDao {

    //需求1: 获取 uid为 001 的用户的所有订单信息
    public List&lt;Orders&gt;  findAllOrders(String uid) throws SQLException {

        QueryRunner qr = new QueryRunner(DruidUtils.getDataSource());

        String sql = &quot;select * from orders where uid = ?&quot;;

        //一个用户所有的订单信息
        List&lt;Orders&gt; ordersList = qr.query(sql, new BeanListHandler&lt;Orders&gt;(Orders.class), uid);

        return ordersList;
    }

    //需求2: 获取订单编号为 order001的订单中的所有商品信息
    public List&lt;Product&gt; findOrderById(String oid) throws SQLException {

        QueryRunner qr = new QueryRunner(DruidUtils.getDataSource());

        //1.查询订单项表 获取订单项表中 订单ID为order001的数据
        String sql = &quot;SELECT pid FROM orderitem WHERE oid = ? &quot;;

        //2.查询的结果是 多条订单项数据
        List&lt;OrderItem&gt; list = qr.query(sql, new BeanListHandler&lt;OrderItem&gt;(OrderItem.class), oid);

        //3.创建集合保存商品信息
        List&lt;Product&gt; productList = new ArrayList&lt;&gt;();

        ProductDao productDao = new ProductDao();

        //4.遍历订单项集合 获取Pid
        for (OrderItem orderItem : list) {

            //4.1从orderitem中获取 pid
            String pid = orderItem.getPid();

            //4.2 调用productDao
            Product product = productDao.findProductById(pid);

            //4.3 保存到集合
            productList.add(product);
        }

        //返回 订单中对应的商品信息
        return productList;
    }


}
</code></pre>
<h4 id="4-3-3-测试OrdersDao"><a href="#4-3-3-测试OrdersDao" class="headerlink" title="4.3.3 测试OrdersDao"></a>4.3.3 测试OrdersDao</h4><pre><code class="java">public class TestOrderDao {

    OrdersDao ordersDao = new OrdersDao();

    //1.获取 uid为 001 的用户的所有订单信息
    @Test
    public void testFindAllOrders() throws SQLException {

        List&lt;Orders&gt; allOrders = ordersDao.findAllOrders(&quot;001&quot;);

        //遍历打印订单信息
        for (Orders order : allOrders) {
            System.out.println(order);
        }
    }

    //测试 获取订单编号为: order001的订单中的所有商品信息
    @Test
    public void testFindOrderById() throws SQLException {

        List&lt;Product&gt; list = ordersDao.findOrderById(&quot;order001&quot;);
        System.out.println(&quot;订单编号为order001中的商品有: &quot;);
        for (Product product : list) {
            System.out.println(product);
        }
    }
}
</code></pre>
